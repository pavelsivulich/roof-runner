<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roof Courier v0.2.9</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #fff; 
            font-size: 20px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 10;
            line-height: 1.4;
        }
        .version {
            font-size: 14px;
            color: #aaa;
            font-weight: normal;
        }
        #start-msg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 20px; text-align: center;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 10px;
            border: 2px solid #fff; pointer-events: none;
            display: block; width: 80%; max-width: 400px;
            line-height: 1.5;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="ui">
        Дистанция: <span id="score">0</span> м<br>
        <span class="version">Версия: 0.2.9</span>
    </div>
    <div id="start-msg">
        КУРЬЕР НА КРЫШАХ<br><br>
        Тапни или Пробел,<br>чтобы прыгать.<br>
        <small style="font-size:0.8em; color:#aaa">В гору бежать тяжелее!</small>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ГЕНЕРАЦИЯ СПРАЙТА ---
    function createHeroSprite() {
        const c = document.createElement('canvas');
        const FRAME_W = 16; const FRAME_H = 16; const COLS = 8; const ROWS = 3;
        c.width = FRAME_W * COLS; c.height = FRAME_H * ROWS;
        const x = c.getContext('2d');
        const C_SKIN = '#ffccaa', C_HAIR = '#2c3e50', C_COAT = '#34495e', C_PANTS = '#1a1a1a', C_SCARF = '#e74c3c';

        const drawFrame = (col, row, legState) => {
            const ox = col * FRAME_W, oy = row * FRAME_H;
            x.fillStyle = C_COAT; x.fillRect(ox + 4, oy + 4, 8, 8);
            x.fillStyle = C_SCARF;
            if (legState === 'jump') x.fillRect(ox, oy + 4, 4, 3);
            else x.fillRect(ox + (col%2===0 ? 0 : 2), oy + 5, 4, 2);
            x.fillStyle = C_SKIN; x.fillRect(ox + 5, oy + 1, 6, 5);
            x.fillStyle = C_HAIR; x.fillRect(ox + 5, oy + 1, 6, 2);
            x.fillStyle = C_PANTS;
            if (legState === 'run1') { x.fillRect(ox + 5, oy + 12, 3, 4); x.fillRect(ox + 8, oy + 11, 3, 3); }
            else if (legState === 'run2') { x.fillRect(ox + 5, oy + 11, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 4); }
            else if (legState === 'run3') { x.fillRect(ox + 6, oy + 12, 4, 4); }
            else if (legState === 'jump') { x.fillRect(ox + 5, oy + 11, 6, 3); }
            else if (legState === 'land1') { x.fillRect(ox + 4, oy + 12, 8, 3); }
            else if (legState === 'land2') { x.fillRect(ox + 5, oy + 12, 6, 3); }
            else if (legState === 'land3') { x.fillRect(ox + 5, oy + 12, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 3); }
        };
        for(let i=0; i<COLS; i++) {
            if(i<4) drawFrame(i, 0, ['run1','run3','run2','run3'][i]);
            else drawFrame(i, 0, ['run1','run3','run2','run3'][i-4]);
            drawFrame(i, 1, 'jump');
            if(i<3) drawFrame(i, 2, ['land1','land2','land3'][i]);
            else drawFrame(i, 2, 'land3');
        }
        return c.toDataURL();
    }
    const heroImage = new Image();
    heroImage.src = createHeroSprite();

    // --- НАСТРОЙКИ ИГРЫ ---
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const BASE_SPEED = 6;
    const BASE_ACCELERATION = 0.001;
    
    const ROOF_CHANCES = [80, 20, 0]; 

    let score = 0;
    let finalScore = 0;
    let frame = 0;
    let isGameOver = false;
    let gameStarted = false;
    let gameSpeed = BASE_SPEED;
    let platforms = [];

    let animFrame = 0, animTimer = 0;
    const ANIM_SPEED_RUN = 6;
    const STATE = { RUN: 0, JUMP_UP: 1, JUMP_DOWN: 2, LAND: 3 };
    let currentState = STATE.RUN;
    let landTimer = 0;

    const player = {
        x: 100, y: 0, width: 32, height: 32,
        vy: 0, grounded: false, angle: 0,
        onSlope: false, currentSlope: 0,
        wasGrounded: false
    };

    // Управление
    function jump() {
        if (!gameStarted) {
            gameStarted = true;
            document.getElementById('start-msg').style.display = 'none';
        }
        if (isGameOver) { resetGame(); return; }
        
        if (player.grounded && (currentState !== STATE.LAND || player.onSlope)) {
             if (player.onSlope || landTimer <= 0) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                player.onSlope = false;
                currentState = STATE.JUMP_UP;
             }
        }
    }
    window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); jump(); }});
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});
    window.addEventListener('mousedown', (e) => { e.preventDefault(); jump(); });

    function resetGame() {
        platforms = [];
        score = 0; finalScore = 0; frame = 0;
        gameSpeed = BASE_SPEED;
        isGameOver = false; gameStarted = false;
        currentState = STATE.RUN; animFrame = 0; landTimer = 0;
        player.y = height - 250; player.vy = 0; player.grounded = true; player.wasGrounded = true;
        player.angle = 0; player.onSlope = false; player.currentSlope = 0;
        
        // Стартовая плоская платформа
        platforms.push({ x: 0, y: height - 150, width: width + 200, height: 200, slope: 0, endY: height - 150, type: 'flat' });
        
        const msg = document.getElementById('start-msg');
        msg.innerHTML = "КУРЬЕР НА КРЫШАХ<br><br>Тапни или Пробел,<br>чтобы прыгать.<br><small style='font-size:0.8em; color:#aaa'>В гору бежать тяжелее!</small>";
        msg.style.display = 'block';
        updateUI();
    }

    function spawnPlatform() {
        const lastP = platforms[platforms.length - 1];
        const gap = 80 + Math.random() * 140;
        const pWidth = 200 + Math.random() * 400;
        
        const rand = Math.random() * 100;
        let type = 'flat';
        if (rand < ROOF_CHANCES[0]) type = 'flat';
        else if (rand < ROOF_CHANCES[0] + ROOF_CHANCES[1]) type = 'slope';
        else type = 'double';

        let startY = lastP.y + (Math.random() - 0.5) * 100;
        if (startY < 150) startY = 150;
        if (startY > height - 100) startY = height - 100;

        let slope = 0;
        let endY = startY;

        if (type === 'slope') {
            slope = (Math.random() - 0.5) * 0.8; 
            endY = startY + slope * pWidth;
            
            if (endY < 100) { slope = (100 - startY) / pWidth; endY = 100; }
            if (endY > height - 50) { slope = (height - 50 - startY) / pWidth; endY = height - 50; }
        }

        platforms.push({ 
            x: lastP.x + lastP.width + gap, 
            y: startY, 
            width: pWidth, 
            height: 400, 
            slope: slope,
            endY: endY,
            type: type
        });
    }

    function update() {
        if (!gameStarted || isGameOver) return;

        player.wasGrounded = player.grounded;
        player.vy += GRAVITY;
        player.y += player.vy;

        let nextGrounded = false;
        let nextOnSlope = false;
        let nextSlope = 0;

        for (let i = 0; i < platforms.length; i++) platforms[i].x -= gameSpeed;
        if (platforms[0].x + platforms[0].width < -100) platforms.shift();
        if (platforms[platforms.length - 1].x < width + 200) spawnPlatform();

        // Коллизия
        for (let p of platforms) {
            if (player.x + player.width > p.x + 5 && player.x < p.x + p.width - 5) {
                const playerCenterX = player.x + player.width / 2;
                const platformHeightAtX = p.y + p.slope * (playerCenterX - p.x);
                
                const feetY = player.y + player.height;
                const collisionThreshold = 15 + Math.abs(p.slope) * gameSpeed * 1.5;

                if (feetY >= platformHeightAtX - 5 && feetY <= platformHeightAtX + collisionThreshold) {
                    if (player.vy >= 0 || player.wasGrounded) {
                        nextGrounded = true;
                        player.vy = 0;
                        player.y = platformHeightAtX - player.height;
                        
                        if (Math.abs(p.slope) > 0.01) {
                            nextOnSlope = true;
                            nextSlope = p.slope;
                        }
                        break;
                    }
                }
            }
        }

        player.grounded = nextGrounded;
        player.onSlope = nextOnSlope;
        player.currentSlope = nextSlope;

        if (player.grounded) {
            if (!player.wasGrounded) {
                currentState = STATE.LAND;
                landTimer = 4;
                animFrame = 0;
            } 
            else if (currentState === STATE.LAND) {
                landTimer--;
                if (landTimer <= 0) { currentState = STATE.RUN; animFrame = 0; }
            } else if (currentState !== STATE.LAND) {
                currentState = STATE.RUN;
            }
            
            if (player.onSlope) {
                player.angle = player.currentSlope * 0.8;
            } else {
                player.angle = 0;
            }
        } else {
            if (player.vy < 0) { currentState = STATE.JUMP_UP; player.angle = 0.25; }
            else { currentState = STATE.JUMP_DOWN; player.angle = -0.15; }
        }

        let currentAccel = BASE_ACCELERATION;
        if (player.onSlope) {
            if (player.currentSlope > 0) {
                currentAccel = BASE_ACCELERATION - 0.002;
                if (currentAccel < -0.0005) currentAccel = -0.0005;
            } else if (player.currentSlope < 0) {
                currentAccel = BASE_ACCELERATION + 0.002;
            }
        }
        
        gameSpeed += currentAccel;
        if (gameSpeed < 2) gameSpeed = 2;

        score += gameSpeed * 0.05;
        updateUI();

        if (player.y > height) {
            isGameOver = true;
            finalScore = Math.floor(score);
            document.getElementById('start-msg').innerHTML = `УПАЛ!<br><br>Дистанция: <b style="color:#ff9f43; font-size:1.2em">${finalScore}</b> м<br><small>Тапни для рестарта</small>`;
            document.getElementById('start-msg').style.display = 'block';
        }

        if (currentState === STATE.RUN) {
            animTimer++;
            if (animTimer > ANIM_SPEED_RUN) { animFrame = (animFrame + 1) % 4; animTimer = 0; }
        } else if (currentState === STATE.LAND) {
            animTimer++;
            if (animTimer > 4) { if (animFrame < 2) animFrame++; animTimer = 0; }
        } else { animFrame = 0; }
        frame++;
    }

    function updateUI() {
        document.getElementById('score').innerText = isGameOver ? finalScore : Math.floor(score);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // Фон
        ctx.fillStyle = '#feca57';
        ctx.beginPath(); ctx.arc(width - 80, 80, 40, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        for(let i=0; i<30; i++) {
            let sx = ((frame * 0.2) + (i * 137)) % width;
            let sy = (i * 23) % (height/2);
            ctx.fillRect(sx, sy, 2, 2);
        }

        // Отрисовка платформ (ИСПРАВЛЕННАЯ ГЕОМЕТРИЯ)
        platforms.forEach(p => {
            if (p.type === 'slope' && Math.abs(p.slope) > 0.01) {
                // --- ЛОГИКА ДЛЯ ОДНОСКАТНОЙ КРЫШИ ---
                // Определяем направления для правильного построения треугольника
                let xLeft = p.x;
                let xRight = p.x + p.width;
                let yLeft = p.y;
                let yRight = p.endY;
                
                let baseY, triangleTopY, rectHeight;

                // Случай 1: Подъем влево-вправо (slope > 0)
                // Левый угол ниже, правый выше.
                // Треугольник лежит наверху справа? Нет, прямоугольный треугольник.
                // Если slope > 0: левый нижний угол дома = (xLeft, yRight).
                // Вершина треугольника (пик) = (xRight, yRight). Начало ската = (xLeft, yLeft).
                // Стоп, нам нужно чтобы персонаж бежал по гипотенузе.
                // Гипотенуза соединяет (xLeft, yLeft) и (xRight, yRight).
                // Чтобы получить прямоугольный треугольник, нам нужен прямой угол.
                // Вариант А: Прямой угол внизу слева. Тогда вертикальный катет слева, горизонтальный внизу.
                //   Вершины: (xLeft, yLeft) [верх ската], (xLeft, yRight) [низ], (xRight, yRight) [конец ската].
                //   Это работает если yLeft < yRight (спуск).
                // Вариант Б: Прямой угол внизу справа.
                //   Вершины: (xLeft, yLeft) [начало ската], (xRight, yLeft) [верх], (xRight, yRight) [низ].
                //   Это работает если yLeft > yRight (подъем).
                
                // Упростим: просто рисуем полигон из 4 точек для всего здания, но разделим визуально.
                // Точки здания:
                // 1. StartTop (xLeft, yLeft)
                // 2. EndTop (xRight, yRight)
                // 3. EndBottom (xRight, yRight + p.height)
                // 4. StartBottom (xLeft, yLeft + p.height) -> НЕТ, это параллелограмм.
                
                // Правильный подход для "дома под скатом":
                // Здание всегда ограничено снизу уровнем max(yLeft, yRight) + p.height.
                // Но мы хотим визуальный стиль: Треугольник сверху + Прямоугольник снизу.
                
                const lowestPoint = Math.max(yLeft, yRight);
                const highestPoint = Math.min(yLeft, yRight);
                const buildingBaseY = lowestPoint + p.height;

                // Цвета
                const colorRoof = '#8395a7'; // Светлее для крыши-треугольника
                const colorWall = '#576574'; // Темнее для стен

                // 1. Рисуем основание (Прямоугольник)
                // Высота прямоугольника = от самой низкой точки ската до низа здания
                ctx.fillStyle = colorWall;
                ctx.fillRect(xLeft, lowestPoint, p.width, buildingBaseY - lowestPoint);

                // 2. Рисуем крышу (Прямоугольный треугольник)
                ctx.fillStyle = colorRoof;
                ctx.beginPath();
                if (p.slope > 0) {
                    // Подъем:左低右高 (Left Low, Right High) -> НЕТ, slope > 0 значит y растет вниз? 
                    // В Canvas Y растет вниз.
                    // slope = (endY - startY) / width.
                    // Если slope > 0, то endY > startY. Значит Правый конец НИЖЕ левого. Это СПУСК.
                    // Если slope < 0, то endY < startY. Значит Правый конец ВЫШЕ левого. Это ПОДЪЕМ.
                    
                    // Исправление логики Canvas:
                    // slope > 0 -> Спуск (вправо вниз).
                    // slope < 0 -> Подъем (вправо вверх).
                    
                    if (p.slope > 0) { 
                        // СПУСК: Левый верх (start), Правый низ (end).
                        // Прямоугольный треугольник: прямой угол в Левом-Низу (под стартом).
                        // Точки: (xLeft, yLeft) -> (xLeft, yRight) -> (xRight, yRight).
                        ctx.moveTo(xLeft, yLeft);
                        ctx.lineTo(xLeft, yRight); // Вертикальный катет
                        ctx.lineTo(xRight, yRight); // Горизонтальный катет (совпадает с низом ската? Нет)
                        // Стоп, гипотенуза должна быть поверхностью.
                        // Если спуск: поверхность от (xLeft, yLeft) до (xRight, yRight).
                        // Чтобы был прямоугольный треугольник ПОД ней:
                        // Вершины: (xLeft, yLeft), (xLeft, yRight), (xRight, yRight).
                        // Да, это прямоугольный треугольник с прямым углом в (xLeft, yRight).
                        ctx.closePath();
                    } else {
                        // ПОДЪЕМ: Левый верх (start, высокий), Правый низ (end, низкий)? Нет.
                        // slope < 0 -> endY < startY. Левый конец НИЖЕ правого? Нет, Y меньше = выше.
                        // startY (левый) больше endY (правый)? Нет.
                        // Пусть startY = 200, endY = 100. slope отрицательный.
                        // Левый конец (200) ниже правого (100). Это ПОДЪЕМ.
                        // Поверхность от (xLeft, 200) до (xRight, 100).
                        // Прямоугольный треугольник под ней: прямой угол в Правом-Низу (под endY? нет, под самым низким).
                        // Самый низкий уровень здесь - startY (200).
                        // Значит прямой угол в (xLeft, startY)? Нет.
                        // Давайте просто построим полигон крыши независимо от типа:
                        // Точки: StartTop, EndTop, и точка прямо под одним из них на уровне другого.
                        
                        // Универсальный способ:
                        // Точка A: (xLeft, yLeft)
                        // Точка B: (xRight, yRight)
                        // Точка C: (xRight, yLeft) -- если рисуем треугольник с прямым углом справа-вверху?
                        // Нам нужно заполнить область ПОД линией AB до уровня min(yLeft, yRight)? Нет, до уровня max.
                        
                        // Просто рисуем полигон здания целиком, но красим верхнюю часть в другой цвет?
                        // Сложно вычислить границу.
                        
                        // Вернемся к простому:
                        // Рисуем весь дом как один полигон (трапецию или сложный полигон), но без дыр.
                        ctx.moveTo(xLeft, yLeft);
                        ctx.lineTo(xRight, yRight);
                        ctx.lineTo(xRight, buildingBaseY);
                        ctx.lineTo(xLeft, buildingBaseY);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Теперь рисуем "крышу" (треугольник) поверх, чтобы выделить цветом
                        ctx.fillStyle = colorRoof;
                        ctx.beginPath();
                        ctx.moveTo(xLeft, yLeft);
                        ctx.lineTo(xRight, yRight);
                        // Третья точка: проекция высшей точки ската на уровень низшей точки ската
                        if (yLeft < yRight) { // Левый выше (Подъем)
                             ctx.lineTo(xLeft, yRight); // Проекция левого на уровень правого
                        } else { // Правый выше (Спуск)
                             ctx.lineTo(xRight, yLeft); // Проекция правого на уровень левого
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        return; // Закончили отрисовку склона
                    }
                }
                
                // Переписанная логика отрисовки для надежности (без ifs для slope знака внутри пути)
                ctx.fillStyle = colorWall;
                const baseLine = Math.max(yLeft, yRight);
                ctx.fillRect(xLeft, baseLine, p.width, buildingBaseY - baseLine);
                
                ctx.fillStyle = colorRoof;
                ctx.beginPath();
                ctx.moveTo(xLeft, yLeft);
                ctx.lineTo(xRight, yRight);
                // Замыкаем треугольник до уровня baseLine
                if (yLeft < yRight) { 
                    // Левый выше. Прямой угол справа внизу относительно треугольника?
                    // Точки: (xLeft, yLeft) -> (xRight, yRight) -> (xLeft, yRight) -> замкнуть
                    ctx.lineTo(xLeft, yRight);
                } else {
                    // Правый выше.
                    // Точки: (xLeft, yLeft) -> (xRight, yRight) -> (xRight, yLeft) -> замкнуть
                    ctx.lineTo(xRight, yLeft);
                }
                ctx.closePath();
                ctx.fill();

            } else {
                // --- ПЛОСКАЯ КРЫША (Старая логика) ---
                ctx.fillStyle = '#576574';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#8395a7';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.width, p.y);
                ctx.stroke();
                
                if (Math.abs(p.slope) < 0.1) {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(p.x + 20, p.y - 30, 10, 30);
                }
            }
        });

        // Персонаж
        if (heroImage.complete && heroImage.naturalWidth !== 0) {
            ctx.save();
            const cx = player.x + player.width / 2;
            const cy = player.y + player.height / 2;
            ctx.translate(cx, cy);
            ctx.rotate(player.angle);
            
            const FRAME_W = 16, FRAME_H = 16;
            let row = 0;
            if (currentState === STATE.JUMP_UP || currentState === STATE.JUMP_DOWN) row = 1;
            if (currentState === STATE.LAND) row = 2;
            let col = animFrame;
            if (row === 1) col = 0;
            if (row === 2 && animFrame > 2) col = 2;

            ctx.drawImage(heroImage, col * FRAME_W, row * FRAME_H, FRAME_W, FRAME_H, -player.width/2, -player.height/2, player.width, player.height);
            ctx.restore();
        } else {
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resetGame();
    loop();
</script>
</body>
</html>
