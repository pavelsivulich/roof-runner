<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roof Courier v0.2.11</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #fff; 
            font-size: 20px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 10;
            line-height: 1.4;
        }
        .version {
            font-size: 14px;
            color: #aaa;
            font-weight: normal;
        }
        #start-msg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 20px; text-align: center;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 10px;
            border: 2px solid #fff; pointer-events: none;
            display: block; width: 80%; max-width: 400px;
            line-height: 1.5;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="ui">
        Дистанция: <span id="score">0</span> м<br>
        <span class="version">Версия: 0.2.11</span>
    </div>
    <div id="start-msg">
        КУРЬЕР НА КРЫШАХ<br><br>
        Тапни или Пробел,<br>чтобы прыгать.<br>
        <small style="font-size:0.8em; color:#aaa">Уровни плавно возвращаются к центру</small>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ГЕНЕРАЦИЯ СПРАЙТА ---
    function createHeroSprite() {
        const c = document.createElement('canvas');
        const FRAME_W = 16; const FRAME_H = 16; const COLS = 8; const ROWS = 3;
        c.width = FRAME_W * COLS; c.height = FRAME_H * ROWS;
        const x = c.getContext('2d');
        const C_SKIN = '#ffccaa', C_HAIR = '#2c3e50', C_COAT = '#34495e', C_PANTS = '#1a1a1a', C_SCARF = '#e74c3c';

        const drawFrame = (col, row, legState) => {
            const ox = col * FRAME_W, oy = row * FRAME_H;
            x.fillStyle = C_COAT; x.fillRect(ox + 4, oy + 4, 8, 8);
            x.fillStyle = C_SCARF;
            if (legState === 'jump') x.fillRect(ox, oy + 4, 4, 3);
            else x.fillRect(ox + (col%2===0 ? 0 : 2), oy + 5, 4, 2);
            x.fillStyle = C_SKIN; x.fillRect(ox + 5, oy + 1, 6, 5);
            x.fillStyle = C_HAIR; x.fillRect(ox + 5, oy + 1, 6, 2);
            x.fillStyle = C_PANTS;
            if (legState === 'run1') { x.fillRect(ox + 5, oy + 12, 3, 4); x.fillRect(ox + 8, oy + 11, 3, 3); }
            else if (legState === 'run2') { x.fillRect(ox + 5, oy + 11, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 4); }
            else if (legState === 'run3') { x.fillRect(ox + 6, oy + 12, 4, 4); }
            else if (legState === 'jump') { x.fillRect(ox + 5, oy + 11, 6, 3); }
            else if (legState === 'land1') { x.fillRect(ox + 4, oy + 12, 8, 3); }
            else if (legState === 'land2') { x.fillRect(ox + 5, oy + 12, 6, 3); }
            else if (legState === 'land3') { x.fillRect(ox + 5, oy + 12, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 3); }
        };
        for(let i=0; i<COLS; i++) {
            if(i<4) drawFrame(i, 0, ['run1','run3','run2','run3'][i]);
            else drawFrame(i, 0, ['run1','run3','run2','run3'][i-4]);
            drawFrame(i, 1, 'jump');
            if(i<3) drawFrame(i, 2, ['land1','land2','land3'][i]);
            else drawFrame(i, 2, 'land3');
        }
        return c.toDataURL();
    }
    const heroImage = new Image();
    heroImage.src = createHeroSprite();

    // --- НАСТРОЙКИ ИГРЫ ---
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const BASE_SPEED = 6;
    const BASE_ACCELERATION = 0.001;
    
    const ROOF_CHANCES = [80, 20, 0]; 
    
    const MIN_ANGLE_DEG = 10;
    const MAX_ANGLE_DEG = 25;
    
    // НАСТРОЙКА "МАГНИТА" К ЦЕНТРУ
    // 0.03 означает, что каждая новая крыша стремится сократить расстояние до центра на 3%.
    // Это слабо заметно на коротких дистанциях, но эффективно на длинных.
    const CENTER_BIAS_STRENGTH = 0.03; 

    let score = 0;
    let finalScore = 0;
    let frame = 0;
    let isGameOver = false;
    let gameStarted = false;
    let gameSpeed = BASE_SPEED;
    let platforms = [];

    let animFrame = 0, animTimer = 0;
    const ANIM_SPEED_RUN = 6;
    const STATE = { RUN: 0, JUMP_UP: 1, JUMP_DOWN: 2, LAND: 3 };
    let currentState = STATE.RUN;
    let landTimer = 0;

    const player = {
        x: 100, y: 0, width: 32, height: 32,
        vy: 0, grounded: false, angle: 0,
        onSlope: false, currentSlope: 0,
        wasGrounded: false
    };

    // Управление
    function jump() {
        if (!gameStarted) {
            gameStarted = true;
            document.getElementById('start-msg').style.display = 'none';
        }
        if (isGameOver) { resetGame(); return; }
        
        if (player.grounded && (currentState !== STATE.LAND || player.onSlope)) {
             if (player.onSlope || landTimer <= 0) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                player.onSlope = false;
                currentState = STATE.JUMP_UP;
             }
        }
    }
    window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); jump(); }});
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});
    window.addEventListener('mousedown', (e) => { e.preventDefault(); jump(); });

    function resetGame() {
        platforms = [];
        score = 0; finalScore = 0; frame = 0;
        gameSpeed = BASE_SPEED;
        isGameOver = false; gameStarted = false;
        currentState = STATE.RUN; animFrame = 0; landTimer = 0;
        player.y = height - 250; player.vy = 0; player.grounded = true; player.wasGrounded = true;
        player.angle = 0; player.onSlope = false; player.currentSlope = 0;
        
        platforms.push({ x: 0, y: height - 150, width: width + 200, height: 200, slope: 0, endY: height - 150, type: 'flat' });
        
        const msg = document.getElementById('start-msg');
        msg.innerHTML = "КУРЬЕР НА КРЫШАХ<br><br>Тапни или Пробел,<br>чтобы прыгать.<br><small style='font-size:0.8em; color:#aaa'>Уровни плавно возвращаются к центру</small>";
        msg.style.display = 'block';
        updateUI();
    }

    function spawnPlatform() {
        const lastP = platforms[platforms.length - 1];
        const gap = 80 + Math.random() * 140;
        const pWidth = 200 + Math.random() * 400;
        
        const rand = Math.random() * 100;
        let type = 'flat';
        if (rand < ROOF_CHANCES[0]) type = 'flat';
        else if (rand < ROOF_CHANCES[0] + ROOF_CHANCES[1]) type = 'slope';
        else type = 'double';

        // --- ЛОГИКА С "МАГНИТОМ" К ЦЕНТРУ ---
        const targetY = height * 0.5; // Цель - середина экрана
        const diff = targetY - lastP.y; // Разница между текущей высотой и целью
        
        // Случайное смещение (-50..+50) + Коррекция к центру (diff * 0.03)
        const randomShift = (Math.random() - 0.5) * 100;
        const biasShift = diff * CENTER_BIAS_STRENGTH;
        
        let startY = lastP.y + randomShift + biasShift;

        // Жесткие границы (на случай экстремальных ситуаций)
        if (startY < 150) startY = 150;
        if (startY > height - 100) startY = height - 100;

        let slope = 0;
        let endY = startY;

        if (type === 'slope') {
            const randomAngleDeg = MIN_ANGLE_DEG + Math.random() * (MAX_ANGLE_DEG - MIN_ANGLE_DEG);
            const direction = Math.random() < 0.5 ? 1 : -1;
            const rad = randomAngleDeg * (Math.PI / 180);
            slope = direction * Math.tan(rad);
            
            endY = startY + slope * pWidth;
            
            // Коррекция только если совсем вылетает за экран
            if (endY < 100) { 
                slope = (100 - startY) / pWidth; 
                endY = 100; 
            }
            if (endY > height - 50) { 
                slope = (height - 50 - startY) / pWidth; 
                endY = height - 50; 
            }
        }

        platforms.push({ 
            x: lastP.x + lastP.width + gap, 
            y: startY, 
            width: pWidth, 
            height: 400, 
            slope: slope,
            endY: endY,
            type: type
        });
    }

    function update() {
        if (!gameStarted || isGameOver) return;

        player.wasGrounded = player.grounded;
        player.vy += GRAVITY;
        player.y += player.vy;

        let nextGrounded = false;
        let nextOnSlope = false;
        let nextSlope = 0;

        for (let i = 0; i < platforms.length; i++) platforms[i].x -= gameSpeed;
        if (platforms[0].x + platforms[0].width < -100) platforms.shift();
        if (platforms[platforms.length - 1].x < width + 200) spawnPlatform();

        // Коллизия
        for (let p of platforms) {
            if (player.x + player.width > p.x + 5 && player.x < p.x + p.width - 5) {
                const playerCenterX = player.x + player.width / 2;
                const platformHeightAtX = p.y + p.slope * (playerCenterX - p.x);
                
                const feetY = player.y + player.height;
                const collisionThreshold = 15 + Math.abs(p.slope) * gameSpeed * 1.5;

                if (feetY >= platformHeightAtX - 5 && feetY <= platformHeightAtX + collisionThreshold) {
                    if (player.vy >= 0 || player.wasGrounded) {
                        nextGrounded = true;
                        player.vy = 0;
                        player.y = platformHeightAtX - player.height;
                        
                        if (Math.abs(p.slope) > 0.01) {
                            nextOnSlope = true;
                            nextSlope = p.slope;
                        }
                        break;
                    }
                }
            }
        }

        player.grounded = nextGrounded;
        player.onSlope = nextOnSlope;
        player.currentSlope = nextSlope;

        if (player.grounded) {
            if (!player.wasGrounded) {
                currentState = STATE.LAND;
                landTimer = 4;
                animFrame = 0;
            } 
            else if (currentState === STATE.LAND) {
                landTimer--;
                if (landTimer <= 0) { currentState = STATE.RUN; animFrame = 0; }
            } else if (currentState !== STATE.LAND) {
                currentState = STATE.RUN;
            }
            
            if (player.onSlope) {
                player.angle = player.currentSlope * 0.8;
            } else {
                player.angle = 0;
            }
        } else {
            if (player.vy < 0) { currentState = STATE.JUMP_UP; player.angle = 0.25; }
            else { currentState = STATE.JUMP_DOWN; player.angle = -0.15; }
        }

        let currentAccel = BASE_ACCELERATION;
        if (player.onSlope) {
            if (player.currentSlope > 0) {
                currentAccel = BASE_ACCELERATION - 0.002;
                if (currentAccel < -0.0005) currentAccel = -0.0005;
            } else if (player.currentSlope < 0) {
                currentAccel = BASE_ACCELERATION + 0.002;
            }
        }
        
        gameSpeed += currentAccel;
        if (gameSpeed < 2) gameSpeed = 2;

        score += gameSpeed * 0.05;
        updateUI();

        if (player.y > height) {
            isGameOver = true;
            finalScore = Math.floor(score);
            document.getElementById('start-msg').innerHTML = `УПАЛ!<br><br>Дистанция: <b style="color:#ff9f43; font-size:1.2em">${finalScore}</b> м<br><small>Тапни для рестарта</small>`;
            document.getElementById('start-msg').style.display = 'block';
        }

        if (currentState === STATE.RUN) {
            animTimer++;
            if (animTimer > ANIM_SPEED_RUN) { animFrame = (animFrame + 1) % 4; animTimer = 0; }
        } else if (currentState === STATE.LAND) {
            animTimer++;
            if (animTimer > 4) { if (animFrame < 2) animFrame++; animTimer = 0; }
        } else { animFrame = 0; }
        frame++;
    }

    function updateUI() {
        document.getElementById('score').innerText = isGameOver ? finalScore : Math.floor(score);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // Фон
        ctx.fillStyle = '#feca57';
        ctx.beginPath(); ctx.arc(width - 80, 80, 40, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        for(let i=0; i<30; i++) {
            let sx = ((frame * 0.2) + (i * 137)) % width;
            let sy = (i * 23) % (height/2);
            ctx.fillRect(sx, sy, 2, 2);
        }

        // Отрисовка платформ
        platforms.forEach(p => {
            if (p.type === 'slope' && Math.abs(p.slope) > 0.01) {
                const xLeft = p.x;
                const xRight = p.x + p.width;
                const yLeft = p.y;
                const yRight = p.endY;
                
                const baseLine = Math.max(yLeft, yRight);
                const buildingBaseY = baseLine + p.height;
                
                const colorRoof = '#8395a7';
                const colorWall = '#576574';

                ctx.fillStyle = colorWall;
                ctx.fillRect(xLeft, baseLine, p.width, buildingBaseY - baseLine);
                
                ctx.fillStyle = colorRoof;
                ctx.beginPath();
                ctx.moveTo(xLeft, yLeft);
                ctx.lineTo(xRight, yRight);
                if (yLeft < yRight) { 
                    ctx.lineTo(xLeft, yRight);
                } else {
                    ctx.lineTo(xRight, yLeft);
                }
                ctx.closePath();
                ctx.fill();

            } else {
                ctx.fillStyle = '#576574';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#8395a7';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + p.width, p.y);
                ctx.stroke();
                
                if (Math.abs(p.slope) < 0.1) {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(p.x + 20, p.y - 30, 10, 30);
                }
            }
        });

        // Персонаж
        if (heroImage.complete && heroImage.naturalWidth !== 0) {
            ctx.save();
            const cx = player.x + player.width / 2;
            const cy = player.y + player.height / 2;
            ctx.translate(cx, cy);
            ctx.rotate(player.angle);
            
            const FRAME_W = 16, FRAME_H = 16;
            let row = 0;
            if (currentState === STATE.JUMP_UP || currentState === STATE.JUMP_DOWN) row = 1;
            if (currentState === STATE.LAND) row = 2;
            let col = animFrame;
            if (row === 1) col = 0;
            if (row === 2 && animFrame > 2) col = 2;

            ctx.drawImage(heroImage, col * FRAME_W, row * FRAME_H, FRAME_W, FRAME_H, -player.width/2, -player.height/2, player.width, player.height);
            ctx.restore();
        } else {
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resetGame();
    loop();
</script>
</body>
</html>
