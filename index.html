<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roof Courier - Fixed Slopes</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #fff; 
            font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 10;
        }
        #start-msg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 20px; text-align: center;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 10px;
            border: 2px solid #fff; pointer-events: none;
            display: block; width: 80%; max-width: 400px;
            line-height: 1.5;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="ui">Дистанция: <span id="score">0</span> м</div>
    <div id="start-msg">
        КУРЬЕР НА КРЫШАХ<br><br>
        Тапни или Пробел,<br>чтобы прыгать.<br>
        <small style="font-size:0.8em; color:#aaa">В гору бежать тяжелее!</small>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ГЕНЕРАЦИЯ СПРАЙТА ---
    function createHeroSprite() {
        const c = document.createElement('canvas');
        const FRAME_W = 16; const FRAME_H = 16; const COLS = 8; const ROWS = 3;
        c.width = FRAME_W * COLS; c.height = FRAME_H * ROWS;
        const x = c.getContext('2d');
        const C_SKIN = '#ffccaa', C_HAIR = '#2c3e50', C_COAT = '#34495e', C_PANTS = '#1a1a1a', C_SCARF = '#e74c3c';

        const drawFrame = (col, row, legState) => {
            const ox = col * FRAME_W, oy = row * FRAME_H;
            x.fillStyle = C_COAT; x.fillRect(ox + 4, oy + 4, 8, 8);
            x.fillStyle = C_SCARF;
            if (legState === 'jump') x.fillRect(ox, oy + 4, 4, 3);
            else x.fillRect(ox + (col%2===0 ? 0 : 2), oy + 5, 4, 2);
            x.fillStyle = C_SKIN; x.fillRect(ox + 5, oy + 1, 6, 5);
            x.fillStyle = C_HAIR; x.fillRect(ox + 5, oy + 1, 6, 2);
            x.fillStyle = C_PANTS;
            if (legState === 'run1') { x.fillRect(ox + 5, oy + 12, 3, 4); x.fillRect(ox + 8, oy + 11, 3, 3); }
            else if (legState === 'run2') { x.fillRect(ox + 5, oy + 11, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 4); }
            else if (legState === 'run3') { x.fillRect(ox + 6, oy + 12, 4, 4); }
            else if (legState === 'jump') { x.fillRect(ox + 5, oy + 11, 6, 3); }
            else if (legState === 'land1') { x.fillRect(ox + 4, oy + 12, 8, 3); }
            else if (legState === 'land2') { x.fillRect(ox + 5, oy + 12, 6, 3); }
            else if (legState === 'land3') { x.fillRect(ox + 5, oy + 12, 3, 3); x.fillRect(ox + 8, oy + 12, 3, 3); }
        };
        for(let i=0; i<COLS; i++) {
            if(i<4) drawFrame(i, 0, ['run1','run3','run2','run3'][i]);
            else drawFrame(i, 0, ['run1','run3','run2','run3'][i-4]);
            drawFrame(i, 1, 'jump');
            if(i<3) drawFrame(i, 2, ['land1','land2','land3'][i]);
            else drawFrame(i, 2, 'land3');
        }
        return c.toDataURL();
    }
    const heroImage = new Image();
    heroImage.src = createHeroSprite();

    // --- НАСТРОЙКИ ИГРЫ ---
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const BASE_SPEED = 6;
    const BASE_ACCELERATION = 0.001;
    
    const ROOF_CHANCES = [80, 20, 0]; 

    let score = 0;
    let finalScore = 0;
    let frame = 0;
    let isGameOver = false;
    let gameStarted = false;
    let gameSpeed = BASE_SPEED;
    let platforms = [];

    let animFrame = 0, animTimer = 0;
    const ANIM_SPEED_RUN = 6;
    const STATE = { RUN: 0, JUMP_UP: 1, JUMP_DOWN: 2, LAND: 3 };
    let currentState = STATE.RUN;
    let landTimer = 0;

    const player = {
        x: 100, y: 0, width: 32, height: 32,
        vy: 0, grounded: false, angle: 0,
        onSlope: false, currentSlope: 0,
        wasGrounded: false // Флаг состояния в прошлом кадре
    };

    // Управление
    function jump() {
        if (!gameStarted) {
            gameStarted = true;
            document.getElementById('start-msg').style.display = 'none';
        }
        if (isGameOver) { resetGame(); return; }
        
        // Разрешаем прыжок, если стоим на земле и не в анимации приземления
        // Или если мы на склоне и просто бежим (игнорируем landTimer на склонах, если не было падения)
        if (player.grounded && (currentState !== STATE.LAND || player.onSlope)) {
             // Дополнительная защита: если на склоне, разрешаем прыжок почти всегда, если grounded=true
             if (player.onSlope || landTimer <= 0) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                player.onSlope = false;
                currentState = STATE.JUMP_UP;
             }
        }
    }
    window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); jump(); }});
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});
    window.addEventListener('mousedown', (e) => { e.preventDefault(); jump(); });

    function resetGame() {
        platforms = [];
        score = 0; finalScore = 0; frame = 0;
        gameSpeed = BASE_SPEED;
        isGameOver = false; gameStarted = false;
        currentState = STATE.RUN; animFrame = 0; landTimer = 0;
        player.y = height - 250; player.vy = 0; player.grounded = true; player.wasGrounded = true;
        player.angle = 0; player.onSlope = false; player.currentSlope = 0;
        
        platforms.push({ x: 0, y: height - 150, width: width + 200, height: 200, slope: 0, endY: height - 150 });
        
        const msg = document.getElementById('start-msg');
        msg.innerHTML = "КУРЬЕР НА КРЫШАХ<br><br>Тапни или Пробел,<br>чтобы прыгать.<br><small style='font-size:0.8em; color:#aaa'>В гору бежать тяжелее!</small>";
        msg.style.display = 'block';
        updateUI();
    }

    function spawnPlatform() {
        const lastP = platforms[platforms.length - 1];
        const gap = 80 + Math.random() * 140;
        const pWidth = 200 + Math.random() * 400;
        
        const rand = Math.random() * 100;
        let type = 'flat';
        if (rand < ROOF_CHANCES[0]) type = 'flat';
        else if (rand < ROOF_CHANCES[0] + ROOF_CHANCES[1]) type = 'slope';
        else type = 'double';

        let startY = lastP.y + (Math.random() - 0.5) * 100;
        if (startY < 150) startY = 150;
        if (startY > height - 100) startY = height - 100;

        let slope = 0;
        let endY = startY;

        if (type === 'slope') {
            // Ограничим максимальный уклон, чтобы избежать совсем экстремальных багов
            // Максимум около 30 градусов (tan(30) ≈ 0.58)
            slope = (Math.random() - 0.5) * 0.8; 
            endY = startY + slope * pWidth;
            
            if (endY < 100) { slope = (100 - startY) / pWidth; endY = 100; }
            if (endY > height - 50) { slope = (height - 50 - startY) / pWidth; endY = height - 50; }
        }

        platforms.push({ 
            x: lastP.x + lastP.width + gap, 
            y: startY, 
            width: pWidth, 
            height: 400, 
            slope: slope,
            endY: endY
        });
    }

    function update() {
        if (!gameStarted || isGameOver) return;

        player.wasGrounded = player.grounded;
        player.vy += GRAVITY;
        player.y += player.vy;

        // Сброс флатов перед проверкой
        let nextGrounded = false;
        let nextOnSlope = false;
        let nextSlope = 0;

        // Движение мира
        for (let i = 0; i < platforms.length; i++) platforms[i].x -= gameSpeed;
        if (platforms[0].x + platforms[0].width < -100) platforms.shift();
        if (platforms[platforms.length - 1].x < width + 200) spawnPlatform();

        // --- УЛУЧШЕННАЯ КОЛЛИЗИЯ ---
        for (let p of platforms) {
            // Горизонтальная проверка
            if (player.x + player.width > p.x + 5 && player.x < p.x + p.width - 5) {
                const playerCenterX = player.x + player.width / 2;
                const platformHeightAtX = p.y + p.slope * (playerCenterX - p.x);
                
                const feetY = player.y + player.height;
                
                // Допуск для коллизии. 
                // Если уклон большой, допуск должен быть больше, т.к. за шаг gameSpeed мы опускаемся сильно.
                // Формула: базовый допуск + компенсация уклона * скорость
                const collisionThreshold = 15 + Math.abs(p.slope) * gameSpeed * 1.5;

                // Проверка: ноги ниже поверхности, но не слишком глубоко (или мы уже были на земле)
                if (feetY >= platformHeightAtX - 5 && feetY <= platformHeightAtX + collisionThreshold) {
                    // Если мы падали сверху ИЛИ уже бежали по этой платформе
                    if (player.vy >= 0 || player.wasGrounded) {
                        nextGrounded = true;
                        player.vy = 0;
                        // Жестко ставим игрока на поверхность, чтобы не было микро-падений
                        player.y = platformHeightAtX - player.height;
                        
                        if (Math.abs(p.slope) > 0.01) {
                            nextOnSlope = true;
                            nextSlope = p.slope;
                        }
                        break; // Нашли платформу
                    }
                }
            }
        }

        player.grounded = nextGrounded;
        player.onSlope = nextOnSlope;
        player.currentSlope = nextSlope;

        // Логика состояний
        if (player.grounded) {
            // Если только что приземлились (были в воздухе)
            if (!player.wasGrounded) {
                currentState = STATE.LAND;
                landTimer = 4;
                animFrame = 0;
            } 
            // Если уже бежим
            else if (currentState === STATE.LAND) {
                landTimer--;
                if (landTimer <= 0) { 
                    currentState = STATE.RUN; 
                    animFrame = 0; 
                }
            } else if (currentState !== STATE.LAND) {
                currentState = STATE.RUN;
            }
            
            // Наклон персонажа
            if (player.onSlope) {
                player.angle = player.currentSlope * 0.8;
            } else {
                player.angle = 0;
            }
        } else {
            // В воздухе
            if (player.vy < 0) { currentState = STATE.JUMP_UP; player.angle = 0.25; }
            else { currentState = STATE.JUMP_DOWN; player.angle = -0.15; }
        }

        // ФИЗИКА СКЛОНА
        let currentAccel = BASE_ACCELERATION;
        if (player.onSlope) {
            if (player.currentSlope > 0) {
                currentAccel = BASE_ACCELERATION - 0.002;
                if (currentAccel < -0.0005) currentAccel = -0.0005;
            } else if (player.currentSlope < 0) {
                currentAccel = BASE_ACCELERATION + 0.002;
            }
        }
        
        gameSpeed += currentAccel;
        if (gameSpeed < 2) gameSpeed = 2;

        score += gameSpeed * 0.05;
        updateUI();

        if (player.y > height) {
            isGameOver = true;
            finalScore = Math.floor(score);
            document.getElementById('start-msg').innerHTML = `УПАЛ!<br><br>Дистанция: <b style="color:#ff9f43; font-size:1.2em">${finalScore}</b> м<br><small>Тапни для рестарта</small>`;
            document.getElementById('start-msg').style.display = 'block';
        }

        // Анимация
        if (currentState === STATE.RUN) {
            animTimer++;
            if (animTimer > ANIM_SPEED_RUN) { animFrame = (animFrame + 1) % 4; animTimer = 0; }
        } else if (currentState === STATE.LAND) {
            animTimer++;
            if (animTimer > 4) { if (animFrame < 2) animFrame++; animTimer = 0; }
        } else { animFrame = 0; }
        frame++;
    }

    function updateUI() {
        document.getElementById('score').innerText = isGameOver ? finalScore : Math.floor(score);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // Фон
        ctx.fillStyle = '#feca57';
        ctx.beginPath(); ctx.arc(width - 80, 80, 40, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#fff';
        for(let i=0; i<30; i++) {
            let sx = ((frame * 0.2) + (i * 137)) % width;
            let sy = (i * 23) % (height/2);
            ctx.fillRect(sx, sy, 2, 2);
        }

        // Платформы
        platforms.forEach(p => {
            ctx.fillStyle = '#576574';
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.width, p.endY);
            ctx.lineTo(p.x + p.width, p.endY + p.height);
            ctx.lineTo(p.x, p.y + p.height);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#8395a7';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.width, p.endY);
            ctx.stroke();
            
            if (Math.abs(p.slope) < 0.1) {
                ctx.fillStyle = '#222';
                ctx.fillRect(p.x + 20, p.y - 30, 10, 30);
            }
        });

        // Персонаж
        if (heroImage.complete && heroImage.naturalWidth !== 0) {
            ctx.save();
            const cx = player.x + player.width / 2;
            const cy = player.y + player.height / 2;
            ctx.translate(cx, cy);
            ctx.rotate(player.angle);
            
            const FRAME_W = 16, FRAME_H = 16;
            let row = 0;
            if (currentState === STATE.JUMP_UP || currentState === STATE.JUMP_DOWN) row = 1;
            if (currentState === STATE.LAND) row = 2;
            let col = animFrame;
            if (row === 1) col = 0;
            if (row === 2 && animFrame > 2) col = 2;

            ctx.drawImage(heroImage, col * FRAME_W, row * FRAME_H, FRAME_W, FRAME_H, -player.width/2, -player.height/2, player.width, player.height);
            ctx.restore();
        } else {
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resetGame();
    loop();
</script>
</body>
</html>
