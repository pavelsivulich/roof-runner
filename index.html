<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Roof Courier 2D - Fixed Anim</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364); 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 20px; left: 20px; color: #fff; 
            font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 10;
        }
        #start-msg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 20px; text-align: center;
            background: rgba(0,0,0,0.85); padding: 20px; border-radius: 10px;
            border: 2px solid #fff; pointer-events: none;
            display: block; width: 80%; max-width: 400px;
            line-height: 1.5;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="ui">Дистанция: <span id="score">0</span> м</div>
    <div id="start-msg">
        КУРЬЕР НА КРЫШАХ<br><br>
        Тапни или Пробел,<br>чтобы прыгать.
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    
    function resize() {
        width = window.innerWidth;        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- ГЕНЕРАЦИЯ СПРАЙТА (ИСПРАВЛЕННАЯ) ---
    function createHeroSprite() {
        const c = document.createElement('canvas');
        // 4 кадра бега + 1 прыжок + 3 приземления = 8 кадров в ширину
        // 3 ряда в высоту
        const FRAME_W = 16;
        const FRAME_H = 16;
        const COLS = 8;
        const ROWS = 3;
        
        c.width = FRAME_W * COLS;
        c.height = FRAME_H * ROWS;
        const x = c.getContext('2d');

        // Цвета
        const C_SKIN = '#ffccaa';
        const C_HAIR = '#2c3e50';
        const C_COAT = '#34495e'; // Темно-синий плащ
        const C_PANTS = '#1a1a1a';
        const C_SCARF = '#e74c3c';

        // Вспомогательная функция рисования персонажа в конкретной позе
        // col: номер колонки (кадра), row: номер ряда
        // pose: тип позы для логики ног
        const drawFrame = (col, row, legState) => {
            const ox = col * FRAME_W;
            const oy = row * FRAME_H;
            
            x.fillStyle = C_COAT;
            // Тело (плащ)
            x.fillRect(ox + 4, oy + 4, 8, 8); 
            
            x.fillStyle = C_SCARF;
            // Шарф (развевается назад)
            if (legState === 'jump') {
                x.fillRect(ox, oy + 4, 4, 3); 
            } else {
                x.fillRect(ox + (col%2===0 ? 0 : 2), oy + 5, 4, 2);
            }

            x.fillStyle = C_SKIN;
            // Голова
            x.fillRect(ox + 5, oy + 1, 6, 5);            
            x.fillStyle = C_HAIR;
            // Волосы
            x.fillRect(ox + 5, oy + 1, 6, 2);

            x.fillStyle = C_PANTS;
            // Ноги (анимация)
            if (legState === 'run1') {
                // Левая нога вперед
                x.fillRect(ox + 5, oy + 12, 3, 4); 
                x.fillRect(ox + 8, oy + 11, 3, 3);
            } else if (legState === 'run2') {
                // Правая нога вперед
                x.fillRect(ox + 5, oy + 11, 3, 3);
                x.fillRect(ox + 8, oy + 12, 3, 4);
            } else if (legState === 'run3') {
                // Ноги вместе (фаза отталкивания)
                x.fillRect(ox + 6, oy + 12, 4, 4);
            } else if (legState === 'jump') {
                // Ноги поджаты
                x.fillRect(ox + 5, oy + 11, 6, 3);
            } else if (legState === 'land1') {
                // Присед глубоко
                x.fillRect(ox + 4, oy + 12, 8, 3);
            } else if (legState === 'land2') {
                // Полуприсед
                x.fillRect(ox + 5, oy + 12, 6, 3);
            } else if (legState === 'land3') {
                // Стойка
                x.fillRect(ox + 5, oy + 12, 3, 3);
                x.fillRect(ox + 8, oy + 12, 3, 3);
            }
        };

        // РЯД 0: БЕГ (4 кадра: 0,1,2,3)
        drawFrame(0, 0, 'run1');
        drawFrame(1, 0, 'run3');
        drawFrame(2, 0, 'run2');
        drawFrame(3, 0, 'run3');
        // Дублируем для плавности (цикл 0-1-2-1-0...)
        drawFrame(4, 0, 'run1'); 
        drawFrame(5, 0, 'run3');
        drawFrame(6, 0, 'run2');
        drawFrame(7, 0, 'run3');

        // РЯД 1: ПРЫЖОК (Используем 0-й кадр ряда, остальные игнорируем)
        drawFrame(0, 1, 'jump');
        // Заполняем остальные кадры ряда тем же, чтобы не было мусора
        for(let i=1; i<COLS; i++) drawFrame(i, 1, 'jump');
        // РЯД 2: ПРИЗЕМЛЕНИЕ (3 кадра: 0,1,2)
        drawFrame(0, 2, 'land1'); // Глубоко
        drawFrame(1, 2, 'land2'); // Средне
        drawFrame(2, 2, 'land3'); // Стойка
        // Остальные кадры ряда - стойка
        for(let i=3; i<COLS; i++) drawFrame(i, 2, 'land3');

        return c.toDataURL();
    }

    const heroImage = new Image();
    heroImage.src = createHeroSprite();

    // --- НАСТРОЙКИ ИГРЫ ---
    const GRAVITY = 0.6;
    const JUMP_FORCE = -14;
    const BASE_SPEED = 6;
    
    let score = 0;
    let finalScore = 0;
    let frame = 0;
    let isGameOver = false;
    let gameStarted = false;
    let gameSpeed = BASE_SPEED;
    let platforms = [];

    // Анимация
    let animFrame = 0;
    let animTimer = 0;
    const ANIM_SPEED_RUN = 6; // Скорость бега (чем меньше, тем быстрее)
    
    // Состояния
    const STATE = { RUN: 0, JUMP_UP: 1, JUMP_DOWN: 2, LAND: 3 };
    let currentState = STATE.RUN;
    let landTimer = 0;

    const player = {
        x: 100, 
        y: 0,
        width: 32,  // Масштабированный размер на экране (спрайт 16px -> 32px)
        height: 32,
        vy: 0,
        grounded: false,
        angle: 0
    };

    // Управление
    function jump() {
        if (!gameStarted) {
            gameStarted = true;            document.getElementById('start-msg').style.display = 'none';
        }
        if (isGameOver) {
            resetGame();
            return;
        }
        if (player.grounded && currentState !== STATE.LAND) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
            currentState = STATE.JUMP_UP;
        }
    }

    window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); jump(); }});
    window.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, {passive: false});
    window.addEventListener('mousedown', (e) => { e.preventDefault(); jump(); });

    function resetGame() {
        platforms = [];
        score = 0;
        finalScore = 0;
        frame = 0;
        gameSpeed = BASE_SPEED;
        isGameOver = false;
        gameStarted = false;
        currentState = STATE.RUN;
        animFrame = 0;
        
        player.y = height - 250; 
        player.vy = 0;
        player.grounded = true;
        player.angle = 0;
        
        platforms.push({ x: 0, y: height - 150, width: width + 200, height: 200 });
        
        const msg = document.getElementById('start-msg');
        msg.innerHTML = "КУРЬЕР НА КРЫШАХ<br><br>Тапни или Пробел,<br>чтобы прыгать.";
        msg.style.display = 'block';
        updateUI();
    }

    function spawnPlatform() {
        const lastP = platforms[platforms.length - 1];
        const gap = 80 + Math.random() * 140;
        const maxJumpHeight = 160;
        let pY = lastP.y + (Math.random() - 0.5) * maxJumpHeight * 1.2;
        if (pY < 150) pY = 150;
        if (pY > height - 100) pY = height - 100;
        platforms.push({ x: lastP.x + lastP.width + gap, y: pY, width: 200 + Math.random() * 400, height: height - pY + 500 });
    }
    function update() {
        if (!gameStarted || isGameOver) return;

        player.vy += GRAVITY;
        player.y += player.vy;

        // Логика состояний
        if (player.grounded) {
            if (currentState === STATE.JUMP_DOWN || currentState === STATE.JUMP_UP) {
                currentState = STATE.LAND;
                landTimer = 12; // Длительность анимации приземления
                animFrame = 0; // Сброс на первый кадр приземления
            } else if (currentState !== STATE.LAND) {
                currentState = STATE.RUN;
            } else {
                landTimer--;
                if (landTimer <= 0) {
                    currentState = STATE.RUN;
                    animFrame = 0;
                }
            }
            player.angle = 0;
        } else {
            if (player.vy < 0) {
                currentState = STATE.JUMP_UP;
                player.angle = 0.25;
            } else {
                currentState = STATE.JUMP_DOWN;
                player.angle = -0.15;
            }
        }

        gameSpeed += 0.0005;
        score += gameSpeed * 0.05;
        updateUI();

        for (let i = 0; i < platforms.length; i++) platforms[i].x -= gameSpeed;
        if (platforms[0].x + platforms[0].width < -100) platforms.shift();
        if (platforms[platforms.length - 1].x < width + 200) spawnPlatform();

        // Коллизия
        player.grounded = false;
        for (let p of platforms) {
            const hOverlap = (player.x + player.width > p.x + 5) && (player.x < p.x + p.width - 5);
            const vOverlap = (player.y + player.height >= p.y) && (player.y + player.height - player.vy <= p.y + 10);
            if (hOverlap && vOverlap && player.vy >= 0) {
                player.grounded = true;
                player.vy = 0;
                player.y = p.y - player.height;            }
        }

        if (player.y > height) {
            isGameOver = true;
            finalScore = Math.floor(score);
            document.getElementById('start-msg').innerHTML = `УПАЛ!<br><br>Дистанция: <b style="color:#ff9f43; font-size:1.2em">${finalScore}</b> м<br><small>Тапни для рестарта</small>`;
            document.getElementById('start-msg').style.display = 'block';
        }

        // Логика анимации кадров
        if (currentState === STATE.RUN) {
            animTimer++;
            if (animTimer > ANIM_SPEED_RUN) {
                // Цикл бега: 0 -> 1 -> 2 -> 3 -> 2 -> 1 (плавный бег туда-сюда)
                // У нас 8 кадров в ряду, используем первые 4 зеркально
                if (animFrame < 3) animFrame++;
                else if (animFrame === 3) animFrame = 2;
                else if (animFrame > 3) animFrame--;
                
                // Простой цикл 0-1-2-3-0-1...
                // Давайте сделаем проще: 0,1,2,3,0,1...
                animFrame = (animFrame + 1) % 4; 
                animTimer = 0;
            }
        } else if (currentState === STATE.LAND) {
            // Анимация приземления: 0 -> 1 -> 2
            animTimer++;
            if (animTimer > 4) {
                if (animFrame < 2) animFrame++;
                animTimer = 0;
            }
        } else {
            // Прыжок: всегда кадр 0 во втором ряду
            animFrame = 0; 
        }

        frame++;
    }

    function updateUI() {
        document.getElementById('score').innerText = isGameOver ? finalScore : Math.floor(score);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);

        // Фон
        ctx.fillStyle = '#feca57';
        ctx.beginPath(); ctx.arc(width - 80, 80, 40, 0, Math.PI * 2); ctx.fill();        ctx.fillStyle = '#fff';
        for(let i=0; i<30; i++) {
            let sx = ((frame * 0.2) + (i * 137)) % width;
            let sy = (i * 23) % (height/2);
            ctx.fillRect(sx, sy, 2, 2);
        }

        // Платформы
        platforms.forEach(p => {
            ctx.fillStyle = '#576574'; 
            ctx.fillRect(p.x, p.y, p.width, p.height);
            ctx.fillStyle = '#8395a7';
            ctx.fillRect(p.x, p.y, p.width, 10);
            ctx.fillStyle = '#222';
            ctx.fillRect(p.x + 20, p.y - 30, 10, 30);
        });

        // ОТРИСОВКА ПЕРСОНАЖА
        if (heroImage.complete && heroImage.naturalWidth !== 0) {
            ctx.save();
            
            const cx = player.x + player.width / 2;
            const cy = player.y + player.height / 2;
            
            ctx.translate(cx, cy);
            ctx.rotate(player.angle);
            
            const FRAME_W = 16;
            const FRAME_H = 16;
            
            // Выбор ряда
            let row = 0; // Бег
            if (currentState === STATE.JUMP_UP || currentState === STATE.JUMP_DOWN) row = 1;
            if (currentState === STATE.LAND) row = 2;
            
            // Выбор колонки (кадра)
            let col = animFrame;
            if (row === 1) col = 0; // Прыжок всегда первый кадр
            if (row === 2 && animFrame > 2) col = 2; // Фиксация последнего кадра приземления

            const sourceX = col * FRAME_W;
            const sourceY = row * FRAME_H;

            // Рисуем изображение, центрируя его
            ctx.drawImage(
                heroImage, 
                sourceX, sourceY, FRAME_W, FRAME_H, 
                -player.width/2, -player.height/2, player.width, player.height
            );
                        ctx.restore();
        } else {
            // Фолбэк (красный квадрат), если картинка еще грузится
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    resetGame();
    loop();
</script>
</body>
</html>
